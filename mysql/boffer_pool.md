[__toc__]


# mysql buffer pool
 [参考文章](https://www.modb.pro/db/111341)
## 预读机制 & 传统LRU缺点
1. 预读：
    - 预读概念：操作系统的磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。
    - 有效性：数据局部性原理
    - 按页（4K）读区与缓冲池关系：缓冲池按页缓存数据，可能访问数据提前放入内存，提高效率
2. LRU：
    - 页已经在缓冲池里，那就只做“移至”LRU头部的动作，而没有页被淘汰。
    - 页不在缓冲池里，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作。
    - 预读失效：由于预读（Read-Ahead），提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效
    - 缓冲池污染：当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。
## mysql采用的LRU（LRU-List）
### mysql的LRU机制优化思路：
   - 让缓冲池里于都失败的缓冲液尽快替换出
   - 将读取的热数据放到LRU头部
### 实现方法：
- 将LRU划分为两部分，新生代（new sublist）老生代（old sublist）5/8:3/8划分——————解决预读失效问题
- 新生代尾部连接老生代
- 新数据也加载时候加载进老生代（头部插入），如果超过1S后再次访问该数据页，在将其诺道新生代头部：1S后是因为再次访问表示该数据很大可能是热数据（只有满足“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；）——————解决缓冲池污染问题，新生链条始终是热数据

## buffer pool中存在三种链表数据Free-List,LRU-List,Flush-List
三种链表数据对应着三种不同的缓冲页类型：
- Free-list：空闲页，未被使用过
- LRU-List：干净页，使用中，即当前内存中的缓冲页跟磁盘中的数据一致
- Flush-List：脏页，同时存在于LRU连表中，此时缓冲页的数据跟磁盘中的数据不一致，需要在适当时机触发flush行为

